## SO21b - trabalho 1

### Esta descrição está em desenvolvimento, incompleta, sendo alterada

Você deve desenvolver um simulador de um processador simples, descrito abaixo.
Esse simulador será usado em outros trabalhos da disciplina.
Pode ser desenvolvido em qualquer linguagem; sugiro alguma orientada a objetos.
Os exemplos serão escritos em C.

O simulador será composto por diversos módulos: memória, entrada e saída, unidade de execução e unidade de controle.

#### Memória

Simula a memória principal do processador.
É constituída por um certo número de células, cada uma identificada por um número (o endereço da célula) e contendo um valor numérico inteiro alterável.
Possui três operações principais:
- uma para obter o tamanho da memória (o número de células que possui);
- uma para obter o valor atual de uma das células, sendo fornecido seu endereço;
- uma para alterar o valor de uma célula, sendo fornecido o endereço e o novo valor.

Nas operações de acesso às células, deve ser possível saber se a operação foi bem sucedida ou se houve algum erro (e qual foi).
Por enquanto, o único erro possível é endereço inválido.
Os endereços válidos são números entre 0 e um a menos que o tamanho da memória.

Exemplo de API para a memória, em C:
```c
   typedef enum {
     MEM_ERR_OK,
     MEM_ERR_END_INV,
   } mem_err_t;

   int mem_tam(mem_t *m);
   mem_err_t mem_le(mem_t *m, int endereco, int *pvalor);
   mem_err_t mem_escreve(mem_t *m, int endereco, int valor);
```

Além dessas operações principais, são necessárias operações auxiliares, pelo menos para a criação e destruição da memória.
Poderia ser, em C:
```c
   mem_t *mem_cria(int tam);
   void mem_destroi(mem_t *m);
```

Dá para implementar como um vetor de inteiros.

#### Entrada e saída

Simula dispositivos de entrada e saída.
Por enquanto, vamos simular somente dispositivos do tipo *stream*, em que os dados não são endereçáveis.
Quando se lê de um dispositivo de entrada, ele fornece o próximo valor disponível (um inteiro).
Não é permitido escrever em um dispositivo de entrada.
Quando se escreve em um dispositivo de saída, ele acrescenta o valor fornecido ao final dos valores ja escritos no dispositivo.
Não é permitido ler de um dispositivo de saída.
Vamos simular por enquanto dois dispositivos, um de entrada (o teclado) e um de saída (o terminal).
Os dispositivos são identificados por um número.
O dispositivo 0 é o teclado e o 1 é o terminal.

Nosso controlador de E/S tem somente duas operações principais, uma para ler um dado de um dispositivo e outra para escrever.
Essas operações devem prever casos de erro, que por enquanto podem ser operação ilegal (tentativa de realizar uma operação inválida em um dispositivo) ou dispositivo inexistente.

A API poderia ser como abaixo, em C:
```c
   typedef enum {
     ES_ERR_OK,
     ES_ERR_DISP_INV,
     ES_ERR_OP_INV,
   } es_err_t;

   es_err_t es_le(es_t *es, int dispositivo, int *pvalor);
   es_err_t es_escreve(es_t *es, int dispositivo, int valor);
```

#### Unidade de execução

Esta é a unidade da CPU responsável pela execução de cada instrução.
Ela é controlada pela unidade de controle, que a chama para cada instrução a ser executada.
Ela tem acesso à unidade de memória, ao controlador de E/S.
Ela mantém o estado interno da CPU (o valor dos registradores).

O estado interno da CPU é constituído de:
- contador de programa - registrador que contém o endereço da memória onde se encontra a próxima instrução a ser executada;
- modo da CPU - registrador que contém o modo de execução da CPU, pode ser:
  - normal - a CPU está apta a executar a próxima instrução;
  - parada - a CPU está com sua execução suspensa, por ter executado uma instrução de parada;
  - em interrupção - a última instrução não pode ser executada e causou uma interrupção;
